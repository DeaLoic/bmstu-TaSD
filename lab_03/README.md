# Отчет по ЛР-3

### Вариант 22. (5)

#### Хетагуров Павел Иу7-35Б

### 1. Описание условия задачи

**Цель:** Цель работы - реализовать алгоритмы обработки разреженных матриц, сравнить
эффективность использования этих алгоритмов (по
времени выполнения и по требуемой памяти) со стандартными алгоритмами обработки
матриц при различном процентном заполнении матриц ненулевыми значениями
и при различных размерах матриц.
**Общее условие задачи:** Разработать программу умножения или сложения разреженных матриц.
Предусмотреть возможность ввода данных, как с клавиатуры, так и использования
заранее подготовленных данных. Матрицы хранятся и выводятся в форме трех
объектов. Для небольших матриц можно дополнительно вывести матрицу в виде
матрицы. Величина матриц - любая (допустим, 1000*1000). Сравнить эффективность
(по памяти и по времени выполнения) стандартных алгоритмов обработки матриц с
алгоритмами обработки разреженных матриц при различной степени разреженности
матриц и различной размерности матриц.

**Вариантное условие задачи:** Разреженная (содержащая много нулей) матрица хранится в форме 3-х объектов:
- вектор A содержит значения ненулевых элементов;
- вектор JA содержит номера столбцов для элементов вектора A;
- связный список IA, в элементе Nk которого находится номер компонент
в A и JA, с которых начинается описание строки Nk матрицы A.
1. Смоделировать операцию умножения вектора-строки и матрицы,
хранящихся в этой форме, с получением результата в той же форме.
2. Произвести операцию умножения, применяя стандартный алгоритм работы с
матрицами.
3. Сравнить время выполнения операций и объем памяти при использовании
этих 2-х алгоритмов при различном проценте заполнения матриц.

#### ТЗ и внешняя спецификация

**Исходные данные и результаты (типы, форматы, способ передачи, ограничения):**

**Исходные данные**:

1. Размер матрицы, ненулевые элементы матрицы в формате (индекс строки, индекс столбца, значение) ,ненулевые элементы вектора-строки в том же формате.

**Способ передачи**: Ввод в консоль (стандартный поток ввода).

**Ограничения**:

1. Элементы - (индекс строки, индекс столбца, значение)целые числа типа int. На моей машине -2^32 ... 2^32 - 1. Переполнение не контролируется
2. Строки вводятся в порядке возрастания индексов.
3. Размер вектора автоматически задается как кол-во столбцов матрицы
3. Если введены некоректные данные - программа просит ввести ещё раз.
4. Допускаются ввод элементов не в порядке следования столбцов
5. Ввод осуществлять без ведущих и заключительных пробелов
6. Вектор умножается на матрицу слева.
7. Для окончания ввода ввести корректную строку, на месте индекса столбца которой стоит -1.

**Выходные данные:**
1. Результат умножения для обоих алгоритмов
2. Процессорные такты для разных процентов разреженности и размеров матриц

**Способ обращения к программе**: Запуск app.exe, ввод с клавиатуры.

**Описание возможных аварийных ситуаций и ошибок пользователя:**

1. Некорректный ввод.
2. Невозможность выделения памяти
3. Переполнение переменной, отвечающей за подсчет кол-ва тактов процессора при выводе информации о сравнении способов (не контролируется)

### 2.Описание внутренних структур данных

**Описание полей**

* .values - массив int, хранит значения ненулевых элементов
* .column_for_values - массив int, хранит индексы столбцов для элементов из .valuesна той же позции
* .rows_start - массив int, хранит индексы в массивах .values и .column_for_values (один индекс, так как они совпадают)
* .cnt_non_zero - int, кол-во ненулевых элементов;
* .n - int, кол-во строк в матрице
* .m - int, кол-во столбцов в матрице

#### 4. Оценка алгоритма.

При хранении матрицы m x n и с кол-вом ненулевых элементов k в разреженном виде
выигрыш по памяти получается, если
1) m > 1 (так как всегда хранятся индексы начала строки, и при m == 1 памяти потратится всегда больше, так как помимо индексов начала строки буду хранится и ненулевые элементы)
2) k < (n * m) / 2 (так как помимо значения ненулевого элемента хранится и индекс его столбца)

По времени при проценте разреженности > 95, так как умножение происходит на нетранспонированную матрицу O(количество строк) * O(время поиска индекса столбца в строке) + O(заполнение буфферного массива) + O(просмотр буферного массива) + O(умножение элементов) = O(n) * O(m) + O(n * m) + O(n * m) + O(n * m) = O((n * m)^2) + O(3 * n * m) - в худшем случае

O((n * m)^2)

### 3.Функциональные тесты

| Исходные данные | Выходные | Описание теста |
| --- | --- | --- |
| **Negative** | | |
| Пустая строка | Повторное приглашение к вводу | Проверка ввода некорректных данных |
| Отрицательное число в размере матрицы | Incorrect input | Проверка ввода некорректного размера |
| Отрицательный столбец/строка или нулевой элемент | Incorrect input | Некорретный ввод |
| В любое поле ввод большего чем требуется кол-ва символов | Incorrect input | Неверная длинна поля |
| Добавление в таблицу с 2000 записями | Max records reached. Cant add even more | Переполнение таблицы |
| Файл не в директории | Cant open file | Ошибка открытия файла |
| Попытка удаления по несуществующему полю | Records doesnt found | Несуществующее поле |
| Выбор пункта по сортировке или вывода при пустой таблице | Phone book is empty | Попытка обработки пустой таблицы |
| **Positive** | | |
| Сортировка отсортированной в обратном порядке таблицы | Корректный вывод | Проверка сортировок |
| Ввод максимальной длинны поля | Корректная работа | Граничное значение длинны поля |
| У всех абонентов одинаковые фамилии. Удаление по ней | Корректная работа (таблица пуста) | Удаление всех записей |
| Сортировка таблицы из одной записи | Таблица не изменилась | Граничные значения для сортировки |

### Контрольные вопросы

#### **Как выделяется память под вариантную часть запись?**

Выделяется память под самую большую возможную часть записи. Вариантная часть всегда последняя в структуре, но может быть вложенная т.е содержать вариантное поле

#### **Что будет, если в вариантную часть ввести данные, несоответствующие описанным?**

Конфликт типов. Ошибка трансляции<br>

#### **Кто должен следить за правильностью выполнения операций с вариантной частью записей?**

Программист

#### **Что представляет собой таблица ключей, зачем она нужна?**

Таблица, элементы исходной таблицы представляются в виде ключа(опорных полей и индекса в исходной таблице)<br>

Нужна для ускорение работы с БД, записи в которой слишком массивны и доступ к каждому из полей записи постоянно не требуется.

#### **В каких случаях эффективнее обрабатывать данные в самой таблице, а в каких - в таблице ключей?**

Если память, занимаемая ключом, несущественно меньше исходной, то при относительно малом количестве записей эффективней будет обрабатывать в самой таблице, так как будет существенный выйгрыш по памяти, и незначительный проигрыш по времени.<br>

В остальных случаях будет незначительный проигрыш по памяти, но существенный выигрыш по времени при обработке в таблице ключей.

#### **Какие способы сортировки предпочтительнее для обработки таблиц и почему?**

Устойчивые - из-за особенностей применения <br>
<br>

Использующие наименьшее кол-во перестановок, так как записи в таблице могут занимать большой объем памяти (их перестановка долгая).<br>

Использующие наименьшее кол-во доп памяти, так как записи в таблице могут занимать большой объем памяти (потребуется слишком много доп памяти)

### Вывод

Так как время работы сортировок зависит как от кол-ва сравниваемых элементов, так и от их размера, то, как проиллюстрировано на скриншоте выше, при увеличении или памяти, или кол-ва элементов - увеличивается время.

Поэтому использование таблицы ключей рационально, так как при том же кол-ве записей уменьшается размер каждой записи и, как следствие, уменьшается время выполнения сортировки.<br>

Таким образом, при увеличении использования памяти в 1.12 раза (для хранения таблицы ключей) скорость выполнения уменьшается примерно в 4 раза.
