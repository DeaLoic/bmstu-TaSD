# Отчет по ЛР-2

### Вариант 22.

#### Хетагуров Павел Иу7-35Б

### 1. Описание условия задачи

**Цель:** приобрести навыки работы с типом данных <<запись>> (структура), содержащим вариантную часть (объединение, смесь), и с данными, хранящимися в таблицах, произвести сравнительный анализ реализации алгоритмов сортировки и поиска информации в таблицах, при использовании записей с большим числом полей, и тех же алгоритмов, при использовании таблицы ключей; оценить эффективность программы по времени и по используемому объему памяти при использовании различных структур и
эффективность использования различных алгоритмов сортировок.

**Общее условие задачи:** Создать таблицу, содержащую не менее 40 записей с вариантной частью. Произвести поиск информации по вариантному полю. Упорядочить таблицу, по возрастанию ключей (где ключ – любое невариантное поле по выбору программиста), используя: 
1. исходную таблицу;
2. массив ключей.

Используя 2 разных алгоритма сортировки. Оценить эффективность этих алгоритмов (по времени и по используемому объему памяти) при различной реализации программы, то есть в случаях 1 и 2. Обосновать выбор алгоритма сортировки. Оценка эффективности должна быть относительной (в %).

**Вариантное условие задачи:** Ввести список абонентов, содержащий фамилию, имя, телефон, адрес, статус (личный – дата рождения: день, месяц, год; служебный – должность, организация). Найти всех друзей, которых необходимо поздравить с днем рождения в ближайшую неделю.

#### ТЗ и внешняя спецификация

**Исходные данные и результаты (типы, форматы, способ передачи, ограничения):**

**Исходные данные**:

1. Файл в phoneBook.csv в формате csv, содержащий на каждой строчке - корректную запись, поля которой разделены симолом `;`. После последней записи **НЕ** следует пустая строка.

**Способ передачи**: Расположение в той же дирректории, что и исполняемый файл. Читается при исполнении программы.

1. Информация, требуемая по заданию, хотя бы для одной записи.

**Способ передачи**: Ввод в консоль (стандартный поток ввода).

Если в программу не будут, переданы исходные данные - функционал будет ограничен.

**Ограничения**:

1. Вводимые поля не могут содержать символ `;`, иначе не гарантируется корректность при работе с файлом (запись и считывание)
2. Поле `birthday` состоит ровно из 8 цифр, дата вводится в формате YYYYMMDD без разделителей. Корректность даты контролируется пользователем.
3. В поле `status` записывается `0`, если статус личный, и `1`, если статус служебный.
4. Допускаются пустые поля, кроме полей `status`, `birthday`, `surname`.
5. Ведущие и заключительные пробелы - считаются частью поля и не удаляются.
6. Максимальный размер таблицы - 2000 записей
7. При расчете дат, считается, что в каждом месяце 31 день
8. Максимальная длинна для полей `surname` и `name` - 63 символов, `address`, `position` и `company` - 127 символов, `phone` - 15 символов.
9. При вводе из файла - корректность данных не проверяется.
10. Нельзя записать пустую таблицу в файл, так как иначе в файле окажутся некоректные данные.
11. Поиск и сортировка регистрочувствительны

**Выходные данные:**

В зависимости от выбранных пунктов.

1. Пункты `Print phone book`, `print key table` и `Print phone book by key table`

выводят в консоль (стандартный поток вывода) таблицу записей, таблицу ключей и таблицу записей по таблице ключей соответственно.

1. Пункт `Compare sort` выводит в консоль (стандартный поток вывода) сравнение по времени пузырьковой и быстрой сортировок для таблиц из 100, 500 и 1000 записей, и соответствующих им таблиц ключей.
2. Пункт `Find friends with birthday in week` выводит в консоль (стандартный поток вывода) записи о людях с личным статусом и днем рождения в пределах недели от вводимой даты.

**Способ обращения к программе**: Запуск app.exe, ввод с клавиатуры или из файла phoneBook.csv, лежащего в той же дирректориии, что и исполняемый файл.

**Описание возможных аварийных ситуаций и ошибок пользователя:**

1. Некорректный ввод.
2. Ошибка открытия файла
3. Невозможность выделения памяти

### 2.Описание внутренних структур данных

**Описание полей**

[privateInfo_t](img/privateinfo.png)

* .birthday - Массив char.

Данная структура выбранна, так как является частью union, и в него может добавлятся информация помимо дня рождения позже.

Поле .birthday является массивом char, так как это позволяет легче сравнивать даты.

[workInfo_t](img/info.png)

* .company - Массив char.
* .position - Массив char

Данная структура выбранна по тем же соображениям, что и privateInfo_t

[extraInfo](img/extrainfo.png)

* .privateInfo - поле типа privateInfo_t.
* .workInfo - поле типа workInfo_t

Структура выбрана, так как позволяет реализовать выбор поля по условию

[subscriber_t](img/subscriber.png)

* .surname - Массив char. Хранит текст
* .name - Массив char. Хранит текст
* .phone - Массив char, так как нет единого формата телефона.
* .address - Массив char. Хранит текст
* .status - enum subscriberStatus.
* .info - поле типа extraInfo. Данные внутри выбираются, основываясь на .status

Была выбрана запись с вариантами, так как при существенном количистве информации любая память - критична. Сэкономить её помогает тип union, который хранит несколько типов данных в одном месте в памяти. Из-за того, что конкретное поле мы выбираем основываясь на поле status, гарантировано, что доступ к полю, ассоциированному с другим статусом нам не потребуется, и, как следствие, можно использовать union.

[subscriberKey_t](img/subscriberKey.png)

* .position - позиция элемента в исходной таблице
* .keySurname - ключ(surname)

В структуре хранится минимальная требуемая информация для обработки данных, что позволяет экономить количество времени, требуемого для обработки исходной структуры (subscriber_t)

[phoneBook_t](img/phoneBook.png)

* .subscribers - динамический массив абонентов
* .subscribersCount - количество абонентов.

Так как заранее неизвестно количество данных, а их размер может быть большим, разумно использовать динамичскую память. В данной структуре находится как динамический массив, так и указание на кол-во элементов в нем.

[phoneBookKeyTable_t](img/keyTable.png)

* .keys - динамический массив ключей на основе абонентов.
* .keysCount - количество ключей.

Так как (phoneBook_t) слишком массивен и долог в обработке, необходимо использовать более маленькую таблицу, содержащую только информацию, необходимую для обработки.

#### 4. Оценка алгоритма.

По памяти без испольщования дополнительного массива ключей: O(n), так как при добавлении новой записи, выделяется место только под неё.

По памяти при использовании дополнительного массива ключей: O(n + 0.12n) = O(n), так как для каждой новой записи необходим новый ключ, а какждый ключ равен 68 байт (против 532 для всей записи)(указано для моей машины).

[sort comparing](img/sortCompare.png)

По времени для сортировки пузырьком: O(время сравнение * число сравнений) + O(время для перемещения памяти * кол-во перемещений)

* O(N^2) + O(time(sizeof(struct)) * N^2) = O(N^2) в худшем<br>
O(N^2) + O(0) = O(N^2) в лучшем<br>
Для qsort O(Время разделения массива * кол-во разбиений)  + O(Время переноса n элементов)
* O(log(n) * n) + O(n * time(sizeof(struct))) - в худшем
* O(n * log(n)) + O(0) - в лучшем

### 3.Функциональные тесты

Так как считается, что в файле все данные корректны - ввод из файла не проверяется.

|  Исходные данные |  Выходные |  Описание теста |
| --- | --- | --- |
| **Negative** |  |  |
|  Пустая строка | Incorrect input |  Проверка ввода некорректных данных |
|  В поле birthday введена буква | Incorrect input |  Проверка ввода некорректного дня рождения |
|  В поле статус введена 2 | Incorrect input |  Некорретный статус |
|  В любое поле ввод большего чем требуется кол-ва символов | Incorrect input |  Неверная длинна поля |
|  Добавление в таблицу с 2000 записями | Max records reached. Cant add even more |  Переполнение таблицы |
|  Файл не в директории | Cant open file |  Ошибка открытия файла |
|  Попытка удаления по несуществующему полю | Records doesnt found |  Несуществующее поле |
|  Выбор пункта по сортировке или вывода при пустой таблице | Phone book is empty |  Попытка обработки пустой таблицы |
| **Positive** |  |  |
|  Сортировка отсортированной в обратном порядке таблицы |  Корректный вывод |  Проверка сортировок |
|  Ввод максимальной длинны поля |  Корректная работа |  Граничное значение длинны поля |
|  У всех абонентов одинаковые фамилии. Удаление по ней |  Корректная работа (таблица пуста) |  Удаление всех записей |
|  Сортировка таблицы из одной записи |  Таблица не изменилась |  Граничные значения для сортировки |

### Контрольные вопросы

#### **Как выделяется память под вариантную часть запись?**

Выделяется память под самую большую возможную часть записи.  Вариантная часть всегда последняя в структуре, но может быть вложенная т.е содержать вариантное поле

#### **Что будет, если в вариантную часть ввести данные, несоответствующие описанным?**

Конфликт типов. Ошибка трансляции<br>

#### **Кто должен следить за правильностью выполнения операций с вариантной частью записей?**

Программист

#### **Что представляет собой таблица ключей, зачем она нужна?**

Таблица, элементы исходной таблицы представляются в виде ключа(опорных полей и индекса в исходной таблице)<br>

Нужна для ускорение работы с БД, записи в которой слишком массивны и доступ к каждому из полей записи постоянно не требуется.

#### **В каких случаях эффективнее обрабатывать данные в самой таблице, а в каких - в таблице ключей?**

Если память, занимаемая ключом, несущественно меньше исходной, то при относительно малом количестве записей эффективней будет обрабатывать в самой таблице, так как будет существенный выйгрыш по памяти, и незначительный проигрыш по времени.<br>

В остальных случаях будет незначительный проигрыш по памяти, но существенный выигрыш по времени при обработке в таблице ключей.

#### **Какие способы сортировки предпочтительнее для обработки таблиц и почему?**

Устойчивые - из-за особенностей применения 

Использующие наименьшее кол-во перестановок, так как записи в таблице могут занимать большой объем памяти (их перестановка долгая).

Использующие наименьшее кол-во доп памяти, так как записи в таблице могут занимать большой объем памяти (потребуется слишком много доп памяти)

### Вывод

Так как время работы сортировок зависит как от кол-ва сравниваемых элементов, так и от их размера, то, как проиллюстрировано на скриншоте выше, при увеличении или памяти, или кол-ва элементов - увеличивается время.

Поэтому использование таблицы ключей рационально, так как при том же кол-ве записей уменьшается размер каждой записи и, как следствие, уменьшается время выполнения сортировки.<br>

Таким образом, при увеличении использования памяти в 1.12 раза (для хранения таблицы ключей) скорость выполнения уменьшается примерно в 4 раза.
